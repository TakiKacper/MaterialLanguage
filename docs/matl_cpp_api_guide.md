# Matl Api
Integrating matl with Your engine is a pretty easy ask, thanks to it's simple api.

## Contents
- [Building](#Building)
- [Minimal matl integration step by step](#Minimal-matl-integration-step-by-step)
  - [Creating Context](#Creating-context)
  - [Parsing Domains](#Parsing-domains)
  - [Parsing Materials](#Creating-context)
  - [Destroying Context](#Destroying-Context)
  - [Minimal Example](#Minimal-Example)
- [Implementing rest of matl features](#Implementing-rest-of-matl-features)
  - [

## Building  
Building matl is similar to compiling single-header library, except you must include several files: matl parser (matl.hpp) and translators.

1. Clone this repo
2. Move source and ``matl.hpp`` files into your project files
3. Create .cpp file ``matl_impl.cpp``
4. Inside put the line ``#define MATL_IMPLEMENTATION``
5. Include ``matl.hpp`` and all of the translators
6. Compile
   
## Minimal matl integration step by step
### Creating context
First of all, we must create a context. Context is an object that contains all informations required to parse matl material into working shader.
```cpp
#include <(path)/matl.hpp>

...
matl::context* context = matl::create_context("opengl_glsl");
```
The argument of create_context is targeted shader language. The function will fail and return nullptr if there is no translator available for such language.

### Parsing Domains
As mentioned in readme, domain is a template of a shader. See ``docs/matl_domains_programming_guide.md`` for more information about them. 
```cpp
matl::domain_parsing_raport raport = matl::parse_domain("my_domain", domain_source, context);
for (auto& error : raport.errors) std::cout << error << '\n';
if (!raport.success) handle_error();
```
matl::parse_domain is a function that loads domain and saves it inside context and returns struct with informations about operation successfulness and errors.
<details>
  <summary>domain_parsing_raport definition</summary>

```cpp
struct domain_parsing_raport
{
    //Whether parsing was successful and there are no errors
    bool success = false;

    //Parsing errors
    std::list<std::string> errors;
};
```
  
</details>
  
First argument is the domain name - this name will be used inside matererials, in ``using domain (domain name)`` line.  
In this simple example we use name ``"my_domain"`` but it is suggested that you use something that represents used shading model or domain use case eg. surface-lit, postprocess, ui etc.   
  
The ``domain_source`` must be of type std::string.

It is worth noting that if parsing fails domain will not be saved inside context, making it also not available for materials.  
You can repeat this step multiple times to add more domains.

### Parsing Materials
Once you have at least one domain loaded into your context you can attempt translating materials.
```cpp
matl::parsed_material mat = matl::parse_material(material_source, context);
for (auto& error : mat.errors) std::cout << error << '\n';
if (!mat.success) handle_error();

...

//If parsing was successfull you can use generated shader sources to create a shader on the gpu
auto shader = create_shader(mat.sources);
```
matl::parse_material takes matl material as a first arg and returns a parsed_material struct.

<details>
<summary>parsed_material definition</summary>

```cpp
struct parsed_material
{
    //Whether parsing was successful and there are no errors
    bool success = false;

    //Shader code in target language
    std::list<std::string> sources;

    //Parsing errors
    std::list<std::string> errors;

    struct parameter
    {
        std::string name;

        enum class type : uint8_t
        {
            boolean,
            scalar,
            vector2,
            vector3,
            vector4,
            texture
        } type;

        std::list<float> numeric_default_value;
        std::string		 texture_default_value;
    };

    //Parameters (directx constants, opengl uniforms ...) generated by material
    std::list<parameter> parameters;
};
```

</details>

### Destroying Context
After you parse all the materials, you should free the context memory using
```cpp
matl::destroy_context(context);
```

### Minimal Example
At this point your application may look like this:
  
<details>
  <summary>Example</summary>

matl_impl.cpp  
```cpp
#define MATL_IMPLEMENTATION
#include "include/matl/matl.hpp"
#include "include/matl/matl_glsl.hpp"
```

main.cpp  
```cpp
#include <iostream>
#include <fstream>

#include "include/matl/matl.hpp"

std::string get_file(const std::string& file_name)
{
    std::fstream t(file_name);

    t.seekg(0, std::ios::end);
    size_t size = t.tellg();
    auto source = std::string(size, ' ');
    t.seekg(0);
    t.read(&source[0], size);

    t.close();

    return source;
}

std::string save_to_file(std::string filename, std::list<std::string>& sources)
{
    std::ofstream content;
    content.open(filename);
    for (auto& source : sources)
	content << source;

    content.close();
}

int main()
{
    //Create context
    auto context = matl::create_context("opengl_glsl");

    //Parse Domain
    matl::domain_parsing_raport dpr = matl::parse_domain("my_domain", get_file("domain.glsl"), context);

    //Parse Material
    matl::parsed_material pm = matl::parse_material(get_file("material.matl"), context);

    //Print Errors
    std::cout << "Domain Errors\n";
    for (auto& err : dpr.errors)
	std::cout << err << '\n';

    std::cout << "Material Errors\n";
    for (auto& error : pm.errors)
	std::cout << error << "\n";

    save_to_file("result_shader.glsl", pm.sources);

    matl::destroy_context(context);
}
```
</details>

















