#pragma once
//matl parser api, exposed to client

namespace matl
{
	std::string get_language_version();

	struct parsed_material
	{
		//Whether parsing was successful and there are no errors
		bool success = false;

		//Shader code in target language
		std::list<std::string> sources;

		//Parsing errors
		std::list<std::string> errors;

		struct parameter
		{
			std::string name;

			enum class type : uint8_t
			{
				boolean,
				scalar,
				vector2,
				vector3,
				vector4,
				texture
			} type;

			std::list<float> numeric_default_value;
			std::string		 texture_default_value;
		};

		//Parameters (directx constants, opengl uniforms ...) generated by material
		std::list<parameter> parameters;
	};

	struct domain_parsing_raport
	{
		//Whether parsing was successful and there are no errors
		bool success = false;

		//Parsing errors
		std::list<std::string> errors;
	};

	struct library_parsing_raport
	{
		//Whether parsing was successful and there are no errors
		bool success = false;

		//Parsed library name
		std::string library_name;

		//Parsing errors
		std::list<std::string> errors;
	};

	struct add_commonly_exposed_functions_raport
	{
		bool success = false;
		std::list<std::string> errors;
	};

	using custom_using_case_callback = void(std::string args, std::string& error);
	using library_source_request = const std::string* (const std::string& lib_name, std::string& error);

	class context;

	context* create_context(std::string target_language);
	void destroy_context(context*);

	parsed_material parse_material(const std::string& material_source, matl::context* context);
	std::list<matl::library_parsing_raport> parse_library(const std::string library_name, const std::string& library_source, matl::context* context);
	domain_parsing_raport parse_domain(const std::string domain_name, const std::string& domain_source, matl::context* context);
}

class matl::context
{
private:
	struct implementation;
	implementation* impl;
	friend parsed_material matl::parse_material(const std::string& material_source, matl::context* context);
	friend std::list<matl::library_parsing_raport> matl::parse_library(const std::string library_name, const std::string& library_source, matl::context* context);
	friend domain_parsing_raport matl::parse_domain(const std::string domain_name, const std::string& domain_source, matl::context* context);

public:
	void add_domain_insertion(std::string name, std::string insertion);
	add_commonly_exposed_functions_raport add_commonly_exposed_functions(const std::string& source);
	void add_custom_using_case_callback(std::string _case, custom_using_case_callback callback);
	void set_library_source_request_callback(library_source_request handle);

private:
	context();
	~context();

	friend context* matl::create_context(std::string target_language);
	friend void matl::destroy_context(matl::context* context);
};